<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Python script by program.think@gmail.com" />
<meta name="provider" content="program-think.blogspot.com" />
<link type="text/css" rel="stylesheet" href="../../css/program-think.css" />
<title>如何保护隐私[6]：如何防范“浏览器指纹”？ - 编程随想的博客</title>
</head>
<body>
<div id="main" style="width:100%;">
<h1><a href="../../index.html" title="回到首页">如何保护隐私[6]：如何防范“浏览器指纹”？</a></h1>
<div class="post-info"><span class="date-header">2014-01-22</span><a href="../../tags/IT.html" class="tag">IT</a> <a href="../../tags/IT.E4BFA1E681AFE5AE89E585A8.html" class="tag">IT.信息安全</a> </div>
<hr/>
<div class="post">
　　前一篇介绍了“<a href="../../2014/01/privacy-protection-5.html">浏览器指纹的基本概念</a>”今天这篇分享一些防范的技巧。<br><a name='more'></a><!--program-think--><br><br><h2>★防范“指纹”的一般性原则？</h2><br>　　不管是哪一种特征，要想成为“指纹”至少要具备两个条件：“唯一性”和“稳定性”。比如人类手指的纹路就同时具有“唯一性”和“稳定性”——任意两个人的纹路都不同，而且每个人的纹路终生不变。所以，要对付“指纹识别”，咱们就必须反其道而行——破坏“唯一性”和“稳定性”。对浏览器而言，做到这两点并不难。且听俺细细道来。<br><br><br><h2>★“浏览器指纹”的构成及信息量</h2><br>　　<a href="../../2014/01/privacy-protection-5.html">前一篇博文</a>已经给大伙儿介绍了 EFF 的浏览器指纹测试工具（链接在“<a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E5%AD%90%E5%89%8D%E5%93%A8%E5%9F%BA%E9%87%91%E4%BC%9A" target="_blank" rel="nofollow">这里</a>”）。通过这个工具可以明显看出，User Agent 的信息量最大，至少占据一半以上的信息量。换句话说，其它所有特征的信息量加起来都没有 User Agent 大。而且除了 User Agent，其它特征的信息量都比较小。这说明啥捏？<br>　　请大伙儿换位思考一下：如果某个网站想要利用浏览器指纹进行用户身份定位，User Agent 是必不可少的一项。缺少这一项，定位的精度会大打折扣。所以，User Agent 是浏览器指纹的关键性信息。<br>　　俺已经在博客中多次唠叨了“<a href="../../2009/02/80-20-principle-0-overview.html">二八原理</a>”，浏览器指纹中的 User Agent 就是这关键性的“20%”。有鉴于此，本文的主要篇幅谈【User Agent】；聊完它之后，再聊另外几种指纹机制及防范。<br><br><br><h2>★如何消除【User Agent】的指纹</h2><br><h3>◇利用浏览器内置的防范措施</h3><br>　　先来聊最简单的招数——使用浏览器内置防御措施。<br>　　要想用这招，首先要判断你使用的浏览器，是否内置了“伪装 User Agent”的功能。<br>　　由于浏览器有很多种，以下介绍用 Firefox 来举例。<br><br>　　Firefox 从版本 59 开始，引入 RFP 功能（这是洋文“Resistance Fingerprinting”的缩写）。如果启用了该功能，Firefox 默认就会伪装 User Agent 的信息——把真实的 User Agent 伪装成某个常见的 User Agent。<br><br>　　<b>本方案的优点</b><br>　　“易用性”很好——你只需开启这个功能，Firefox 自动就帮你伪装好了。<br><br>　　<b>本方案的缺点</b><br>　　主要缺点是“不够彻底”——由于 Firefox 使用某个固定且常见的“User Agent 值”进行伪装。因此，目标网站依然【有可能】判断出你在使用 Firefox。仅仅知道你在使用 Firefox，这个信息量【很小】。因此，这个缺点不严重。<br><br><h3>◇“多浏览器”方案</h3><br>　　这个方案最简单，也最容易想到。一看这个小标题，估计大部分读者都猜到俺想喷啥口水。<br>　　如果你同时具有两个不同的浏览器（比如：一个 Firefox 一个 Chrome），那么这两个浏览器必然具有不同的 User Agent。如果某个网站收集了浏览器指纹，而你又想在这个网站注册两个不同的马甲，那么你就可以用“多浏览器方案”——分别用不同的浏览器注册不同的马甲。<br><br>　　<b>本方案的优点</b><br>　　操作很简单，会装浏览器的同学都玩。<br><br>　　<b>本方案的缺点</b><br>　　浏览器的种类毕竟有限（知名且靠谱的浏览器，一只手都能数过来）。万一你想注册十多个马甲，用这个方案就显得傻逼了。<br><br><h3>◇“多实例”方案</h3><br>　　为了解决“多浏览器方案”的局限性，自然会想到“多实例”这个方案。此招数俺曾经在《<a href="../../2010/06/howto-prevent-hacker-attack-0.html">如何防止黑客入侵</a>》系列博文中介绍过。<br>　　在主流的三大浏览器中，Firefox 和 Chrome 支持“多实例”，IE 不支持。所以那些喜欢 IE 的同学就没法用这招了。<br>　　关于 Firefox 和 Chrome 如何配置多实例，请看俺之前的博文（<a href="../../2012/09/howto-prevent-hacker-attack-6.html#multi_profile">这里</a>）。对于用 Chrome 的同学，俺再次罗嗦一下：Chrome 同时提供“多实例”（洋文叫“Multiple Profiles”）和“多用户”（洋文叫“Multiple Accounts”）两种功能，这两者是完全不同滴。它的“多用户”依然在同一个“实例”中。<br> 　　<b>配置完“多实例”之后，一定要记得修改每一个实例的 User Agent，并确保【两两不同】。</b>至于如何修改 User Agent 请参见“<a href="../../2013/07/privacy-protection-4.html#user_agent">这篇博文</a>”——里面提供了三大主流浏览器的修改方法。<br><br>　　<b>本方案的优点</b><br>　　浏览器的实例可以配置任意多个（只要你有耐心，硬盘够大，配几百几千都可以）。<br><br>　　<b>本方案的缺点</b><br>　　某些浏览器（比如 IE）不支持多实例。<br><br><h3>◇“多虚拟机”方案</h3><br>　　要对付 User Agent 的指纹，前面两招基本够用了。但某些同学可能有特殊需求，或者安全要求比较高，所以俺顺便介绍第三种方法。<br>　　第三种方法就是利用虚拟机软件安装不同的虚拟系统，然后在每个虚拟系统中安装浏览器。没用过虚拟化软件的同学，先看俺之前的扫盲教程（在“<a href="../../2012/10/system-vm-0.html">这里</a>”）。再次罗嗦：如果你在不同的虚拟机中安装相同的浏览器，要记得修改【每个】虚拟机中浏览器的 User Agent。<br><br>　　<b>本方案的优点</b><br>　　优点1：前面说了，某些浏览器不支持多实例。万一你偏偏喜欢这种浏览器，就可以考虑用“多虚拟机”的方案。<br>　　优点2：因为屏幕分辨率、系统时区也都是指纹特征。所以在虚拟系统中，你还可以调整屏幕分辨率和时区（使之不同于你真实系统的分辨率和时区）。<br><br>　　<b>本方案的缺点</b><br>　　缺点1：你需要额外安装虚拟化软件，然后再安装虚拟系统。过程稍嫌繁琐。对技术菜鸟也有难度。<br>　　缺点2：对系统的硬件有一定的要求（如果你的电脑硬件太寒酸，就甭考虑这招啦）。<br><br><h3>◇“动态 User Agent”方案</h3><br>　　（现在来聊最高级，也最难的方案）<br>　　善于思考的同学会发现：前面三个招数，其本质是相通滴。说白了都是利用技术手段“隔离”出不同的浏览器环境，然后单独修改每个环境的指纹，以此来伪造出多个身份。但是对于每一个具体的环境，其指纹依然是固定的。换句话说，前面那三个招数都是针对指纹的【唯一性】。下面俺要介绍的招数可以用来破坏指纹的【稳定性】。<br>　　前面说了，浏览器指纹的信息量，至少有一半以上是来自于 User Agent。所以要破坏浏览器指纹的稳定性，只要让浏览器的 User Agent 动态变化即可。下面分别说明技术思路（以下的招数适合于有一定折腾能力的同学，需要用到一点点编写脚本的伎俩）。<br><br>　　<b>如何获取常见的 User Agent</b><br>　　要构造随机的 User Agent ，其实也不难。到“<a href="http://www.useragentstring.com/" target="_blank" rel="nofollow">这个网站</a>”可以看到各种各样浏览器的 User Agent。你可以收集一大堆预存着，然后每次从中随机挑选一条作为你的伪装。为了做到每次随机挑选并设置，你可以写一个脚本来干这事儿，然后顺便让这个脚本来帮你启动浏览器。<br>　　再唠叨一下：挑选 User Agent 是有讲究滴，要尽量选择那些比较常见的 User Agent——越常见的 User Agent 所包含的信息量越小。<br><br>　　<b>对 Firefox 的定制</b><br>　　三大浏览器中，最有利于隐私保护的是 Firefox（具体的原因分析请看本系列<a href="../../2013/06/privacy-protection-2.html">前面的博文</a>），所以先说它的技术实现。<br><br>　　通过修改 <code>user.js</code> 文件，可以手工指定 Firefox 使用的 User Agent。具体做法是：往 <code>user.js</code> 添加一个配置项，其“名称”是 <code>general.useragent.override</code>，其“值”就是“伪装的 User Agent”。<br>　　如何修改 <code>user.js</code>，请参见博文：《<a href="../../2019/07/Customize-Firefox.html">扫盲 Firefox 定制——从“user.js”到“omni.ja”</a>》<br><br>　　上述做法只能达到【静态】效果——你伪装了 User Agent 之后，它就一直保持你设定的值。<br>　　要想做到【动态】的效果，就需要用到【脚本】来自动修改 <code>user.js</code> 文件里面关于 <code>general.useragent.override</code> 的那行代码，每次修改都使用某个【随机选定】的 User Agent。修改完 <code>user.js</code> 之后再把 Firefox 启动起来。<br>　　对于 Windows 下的 Firefox，可以用 VBScript 或 JScript 或 PowerShell 这三种系统内置的脚本；对于 Linux 或苹果系统，可以尝试各种 shell 脚本。<br>　　某些爱思考的同学可能会问，为啥不直接在 <code>user.js</code> 文件里面用 javascript 代码进行 User Agent 的随机生成。<br>　　俺也曾经企图这么干，可惜不行！因为 <code>user.js</code> 中对函数 <code>user_pref</code> 的调用，两个参数都必须是【常量】；而且， <code>user.js</code> 中除了调用该函数，不允许再出现其它的代码行。<br><br>　　<b>对 Chrome 的定制</b><br>　　对于 Chrome，可以在命令行参数指定其 User Agent，具体请参见“<a href="../../2013/07/privacy-protection-4.html#user_agent">这篇博文</a>”。<br>　　所以，你可以自己写一个脚本，专门用来启动 Chrome。每次启动都传递一个随机的 User Agent 作为命令行参数。<br>　　对于 Windows 下的 Chrome，可以用 VBScript 或 JScript 或 PowerShell 这三种系统内置的脚本；对于 Linux 或苹果系统，可以尝试各种 shell 脚本。<br><br>　　<b>对 IE 的定制</b><br>　　对于 IE 的 User Agent，需要修改注册表的键值（<code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings\User Agent</code>）。所以捏，可以通过事先写好的脚本（VBScript 或 JScript 或 PowerShell）往相应的注册表键值中写入随机的User Agent，然后再由这个脚本启动 IE。<br><br><h3>◇补充说明</h3><br>　　（本文发出之后，看到某些读者留言，特地补充这个小节）<br>　　对于“动态 UserAgent 方案”，很多读者在问：为啥不直接给出代码？<br>　　俺提醒一下：【<b>授人以鱼不如授人以渔</b>】是本博客长期奉行的原则。所以在技术方面，俺更愿意分享一些思路，尽量避免直接给出现成的东西。自己动手实践，有助于能力的提升而且印象更深刻。<br>　　如果你是个程序猿/程序媛，写这样一个脚本应该是易如反掌滴；如果你不是搞技术的，顺便学一下简易的脚本编程（其实很容易滴）。不会编程的同学，俺建议从 Python 开始入手，功能强且门槛低，具体请参见《<a href="../../2009/08/why-choose-python-0-overview.html">为啥俺推荐 Python</a>》系列博文。<br><br><br><h2>★如何消除【屏幕分辨率】的指纹</h2><br><h3>◇“屏幕分辨率”的信息量</h3><br>　　对于【不】使用虚拟机的普通网友，其屏幕分辨率也就是【常见】的那几种（大概在20种以内）——这种情况下，“屏幕分辨率”暴露出的信息量【很低】，不要紧。<br>　　但如果你使用“操作系统虚拟机”，就需要留意“屏幕分辨率的问题”。<br>　　当你在 Guest OS 中上网，并且你【没有】使用全屏模式，那么 Guest OS 的分辨率可能会是一个很奇怪的分辨率（因为独特性很高，会包含【很多】的“指纹信息量”）。所以，俺建议那些用虚拟系统上网的同学，采用如下几个措施：<br><br><h3>◇如何防范</h3><br>　　<b>措施1：每个 VM 都采用“全屏模式”</b><br>　　这个方案针对的是——【普通】的隐私需求。<br>　　VM 全都采用【全屏】，虽然每个 VM 的分辨率相同。但至少这个分辨率是某个【常见】的分辨率，因此【信息量很低】。<br><br>　　<b>措施2：对每个 VM 都采用某个常见的分辨率（【非】全屏），且每个 VM 的分辨率【各不相同】</b><br>　　这个方案针对的是——【特别高】的隐私需求。<br>　　由于每个 VM 的分辨率各不相同，假设网站收集了分辨率作为指纹，不同 VM 的上网身份，会被识别为【不同身份】。<br><br><br><h2>★如何消除【Canvas】的指纹</h2><br><h3>◇“Canvas”是啥玩意儿？</h3><br>　　在本文发布约半年后，有读者在博客留言中询问了“基于 HTML5 的 Canvas 语法进行指纹追踪”。所以俺单独补充了这个章节。<br>　　所谓的“Canvas 指纹”，依赖的是 HTML5 新增的 Canvas 语法。利用这个 Canvas 语法可以实现一些绘图的功能。由于不同类型的浏览器使用了不同的绘图引擎；并且同一种浏览器在不同操作系统平台上，绘图引擎的特性也会有细微的差别。因此，“Canvas 的功能特性”会成为某种指纹信息。<br><br><h3>◇如何防范</h3><br>　　Canvas 的绘图功能要依赖于 JS 脚本。因此，只需“禁用 JS 脚本”就可以让“Canvas 指纹”失效。<br>　　俺的建议是：使用一些安全扩展（比如 NoScript），对你不信任的网站禁用 JS 脚本。另外，电子前哨基金会（EFF）提供的“Privacy Badger 扩展”，也可以屏蔽“Canvas 指纹”。<br>　　要测试自己的浏览器是否存在“Canvas 指纹”，请猛击“<a href="https://www.browserleaks.com/canvas" target="_blank" rel="nofollow">这个链接</a>”。<br>　　对于 Firefox 浏览器，从版本 59 开始，已经引入 RFP（洋文“Resistance Fingerprinting”的缩写），默认就会限制 Canvas 指纹。<br>　　退一步讲，就算你无法屏蔽“Canvas 指纹”，也不用怕。在本文开头提到了“防范指纹的一般性原则”，其中之一是【破坏唯一性】。前面章节介绍了几个招数，用来破坏“User Agent 的唯一性”。这些招数也可以用来破坏“Canvas 的唯一性”。<br>　　提醒一下：单纯用“多实例”的招数无法破坏“Canvas 指纹”的唯一性。因为在“多实例”的情况下，每个实例共享【同一个】浏览器引擎。所以你必须采用“多浏览器”或者“多虚拟机”的方式。<br><br><br><h2>★补充说明： EFF 的浏览器指纹测试</h2><br>　　<a href="../../2014/01/privacy-protection-5.html">前一篇博文</a>介绍了 EFF 的浏览器指纹测试工具，估计很多同学都去测试了。其实捏，不必太在意具体每一项的“比特数”。大伙儿只需要关注其“定性”而不必太在意其“定量”。因为 EFF 网站目前收集的样本还不够多（只有几百万），所以其分析出的信息量（相比全球的统计数据）会有所偏差。<br>　　另外，很多人测试下来的总信息量是 21.85 bits，这是因为 EFF 的总样本目前只有 370万 左右（370万 约等于“2的21.85次方”）。所以比特数到 21.85 就封顶了。<br><br><br><a href="../../2013/06/privacy-protection-0.html#index">回到本系列的目录</a><div class="blogger-post-footer">
</div>
<hr/>
<div class="copyright">
<h4>版权声明</h4>
本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者<a href="mailto:program.think@gmail.com">编程随想</a>和本文原始网址：<br>
<a href="https://program-think.blogspot.com/2014/01/privacy-protection-6.html">https://program-think.blogspot.com/2014/01/privacy-protection-6.html</a>
</div>
</div>
</body>
</html>
